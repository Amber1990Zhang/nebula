{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the official Nebula Graph documentation. \u00b6 Nebula Graph is a distributed, scalable, lightning-fast graph database. It is the only solution in the world capable to host graphs with dozens of billions of vertices (nodes) and trillions of edges, while still provides millisecond latency. Nebula Graph's goal is to provide reading, writing, and computing with high concurrency, low latency for super large scale graphs. Nebula is an open source project and we are looking forward to working with the community to popularize and promote the graph database. Nebula Graph's primary features Symmetrically distributed Highly scalable Fault tolerant SQL-like query language How can I get Nebula \u00b6 Nebula Graph source code is available here on Github . The currently release is version 0.1. You can also download docker image to try it. More details on how to get Nebula image click Get Started . How can I contribute \u00b6 As the team behind Nebula Graph , we fully commit to the community and all-in to the open source project. All the core features are and will be implemented in the open source repository. We also encourage the community to involve the project. There are a few ways you can contribute: You can download and try Nebula Graph , and provide us feedbacks You can submit your feature requirements and bug reports You can help contribute the documentations. More details on how to contribute click Contribute to Nebula Graph Docs You can fix bugs or implement features. More details on how to build the project and submit the Pull Requests click Contribute to Nebula Graph Licensing \u00b6 Nebula Graph is under Apache 2.0 license, so you can freely download, modify, deploy the source code to meet your needs. You can also freely deploy Nebula Graph as a back-end service to support your SAAS deployment. In order to prevent cloud providers monetarizing from the project without contributing back, we added Common Clause 1.0 to the project. As mentioned above, we fully commit to the open source community. We would love to hear your thoughts on the licensing model and are willing to make it more suitable for the community. Our Community \u00b6 Please use GitHub issue tracker for reporting bugs or feature requests. Join .","title":"Home"},{"location":"#welcome-to-the-official-nebula-graph-documentation","text":"Nebula Graph is a distributed, scalable, lightning-fast graph database. It is the only solution in the world capable to host graphs with dozens of billions of vertices (nodes) and trillions of edges, while still provides millisecond latency. Nebula Graph's goal is to provide reading, writing, and computing with high concurrency, low latency for super large scale graphs. Nebula is an open source project and we are looking forward to working with the community to popularize and promote the graph database. Nebula Graph's primary features Symmetrically distributed Highly scalable Fault tolerant SQL-like query language","title":"Welcome to the official Nebula Graph documentation."},{"location":"#how-can-i-get-nebula","text":"Nebula Graph source code is available here on Github . The currently release is version 0.1. You can also download docker image to try it. More details on how to get Nebula image click Get Started .","title":"How can I get Nebula"},{"location":"#how-can-i-contribute","text":"As the team behind Nebula Graph , we fully commit to the community and all-in to the open source project. All the core features are and will be implemented in the open source repository. We also encourage the community to involve the project. There are a few ways you can contribute: You can download and try Nebula Graph , and provide us feedbacks You can submit your feature requirements and bug reports You can help contribute the documentations. More details on how to contribute click Contribute to Nebula Graph Docs You can fix bugs or implement features. More details on how to build the project and submit the Pull Requests click Contribute to Nebula Graph","title":"How can I contribute"},{"location":"#licensing","text":"Nebula Graph is under Apache 2.0 license, so you can freely download, modify, deploy the source code to meet your needs. You can also freely deploy Nebula Graph as a back-end service to support your SAAS deployment. In order to prevent cloud providers monetarizing from the project without contributing back, we added Common Clause 1.0 to the project. As mentioned above, we fully commit to the open source community. We would love to hear your thoughts on the licensing model and are willing to make it more suitable for the community.","title":"Licensing"},{"location":"#our-community","text":"Please use GitHub issue tracker for reporting bugs or feature requests. Join .","title":"Our Community"},{"location":"contribute-to-documentation/","text":"Contribute to documentation \u00b6 Contributing to the Nebula documentation can be a rewarding experience. We welcome your participation to help make the documentation better! How to contribute to the docs \u00b6 There are many ways to contribute: Edit, rate, or file an issue or question directly on the site by using the pencil mark available on the right-side on every page. File a documentation issue on GitHub at https://github.com/vesoft-inc/nebula/issues. Fork the documentation, make changes or add new content on your local branch, and submit a pull request (PR) to the master branch for the docs.","title":"Contribute to docs"},{"location":"contribute-to-documentation/#contribute-to-documentation","text":"Contributing to the Nebula documentation can be a rewarding experience. We welcome your participation to help make the documentation better!","title":"Contribute to documentation"},{"location":"contribute-to-documentation/#how-to-contribute-to-the-docs","text":"There are many ways to contribute: Edit, rate, or file an issue or question directly on the site by using the pencil mark available on the right-side on every page. File a documentation issue on GitHub at https://github.com/vesoft-inc/nebula/issues. Fork the documentation, make changes or add new content on your local branch, and submit a pull request (PR) to the master branch for the docs.","title":"How to contribute to the docs"},{"location":"cpp-coding-style/","text":"Please Refer to Google C++ Style Guide .","title":"Cpp coding style"},{"location":"developer-documentation-style-guide/","text":"Key Point: Use this guide as a style reference for our developer documentation. Goals \u00b6 The guide can help you avoid making decisions about the same issue over and over, can provide editorial assistance on structuring and writing your documentation, and can help you keep your documentation consistent with our other documentation. Non-goals \u00b6 This guide isn't intended to provide an industry documentation standard, nor to compete with other well-known style guides. It's a description of our house style, not a statement that our decisions are objectively correct. This guide is a living document; it changes over time, and when it changes, we generally don't change previously published documentation to match. We strive for consistency to the extent feasible, but at any given time there are certain to be parts of our documentation that don't match this style guide. When in doubt, follow this guide rather than imitating existing documents. Breaking the \"rules\" \u00b6 In most contexts, Nebula has no ability nor desire to enforce these guidelines if they're not appropriate to the context. But we hope that you'll join us in striving for high-quality documentation. Like most style guides, our style guide aims to improve our documentation, especially by improving consistency; therefore, there may be contexts where it makes sense to diverge from our guidelines in order to make your documentation better. Style and authorial tone \u00b6 Aim, in your documents, for a voice and tone that's conversational, friendly, and respectful without being overly colloquial or frivolous; a voice that's casual and natural and approachable, not pedantic or pushy. Try to sound like a knowledgeable friend who understands what the developer wants to do. Don't try to write exactly the way you speak; you probably speak more colloquially and verbosely than you should write, at least for developer documentation. But aim for a conversational tone rather than a formal one. Some techniques and approaches to consider \u00b6 If you're having trouble expressing something, step back and ask yourself, \"What am I trying to say?\" Often, the answer you give yourself reveals what you should be saying in the document. If you're uncertain about your phrasing or tone, ask a colleague to take a look. Try reading parts of your document out loud, or at least mouthing the words. Does it sound natural? Not every sentence has to sound natural when spoken; these are written documents. But if you come across a sentence that's awkward or confusing when spoken, consider whether you can make it more conversational. Use transitions between sentences. Phrases like \"Though\" or \"This way\" can make paragraphs less stilted. (Then again, sometimes transitions like \"However\" or \"Nonetheless\" can make paragraphs more stilted.) Even if you're having trouble hitting the right tone, make sure you're communicating useful information in a clear and direct way; that's the most important part. Tense \u00b6 In general, use present tense rather than future tense; in particular, try to avoid using will where possible. The fact that the reader will be writing and running code in the future isn't a good reason to use future tense. Stick with present tense where. Also avoid the hypothetical future would . Links \u00b6 When you're writing link text, use a phrase that describes what the reader will see after following the link. That can take either of two forms: - The exact title of the linked-to page, capitalized the same way the title is capitalized. - A description of the linked-to page, capitalized like ordinary text instead of like a title. A couple of specific things to not do in link text: - Don't use the phrase \"click here.\" (It's bad for accessibility and bad for scannability.) - Similarly, don't use phrases like \"this document.\" (It's easy to read \"this\" as meaning \"the one you're reading now\" rather than \"the one I'm pointing to.\") - Don't use a URL as link text. Instead, use the page title or a description of the page. Punctuation with links \u00b6 If you have punctuation immediately before or after a link, put the punctuation outside of the link tags where possible. In particular, put quotation marks outside of link tags. Accessible content \u00b6 General dos and don'ts \u00b6 Ensure that readers can reach all parts of the document (including tabs, form-submission buttons, and interactive elements) using only a keyboard, without a mouse or trackpad. Don't use color, size, location, or other visual cues as the primary way of communicating information. If you're using color, icon, or outline thickness to convey state, then also provide a secondary cue, such as a change in the text label. Refer to buttons and other elements by their label (or aria-label , if they\u2019re visual elements), not by location or shape. Avoid unnecessary font formatting. (Screen readers explicitly describe text modifications.) If you're documenting a product that includes specialized accessibility features, then explicitly document those features. For example, the gcloud command-line tool includes togglable accessibility features such as percentage progress bars and ASCII box rendering. Images \u00b6 For every image, provide alt text that adequately summarizes the intent of each image. Don't present new information in images; always provide an equivalent text explanation with the image. Use SVG files or crushed PNG images. Provide high-resolution images when practical. Tables \u00b6 If your tables include both row and column headings, then mark heading cells with the scope attribute. If your tables have more than one row containing column headings, then use the headers attribute. Forms \u00b6 Label every input field, using a <label> element. Place labels outside of fields. When you're creating an error message for form validation, clearly state what went wrong and how to fix it. For example: \"Name is a required field.\" Videos \u00b6 Provide captions. Ensure that captions can be translated into major languages. Language and grammar \u00b6 Use second person: \"you\" rather than \"we.\" Use active voice; make clear who's performing the action. Use standard American spelling and punctuation. Put conditional clauses before instructions, not after. For usage and spelling of specific words, see the word list. Formatting, punctuation, and organization \u00b6 Use sentence case for document titles and section headings. Use numbered lists for sequences. Use bulleted lists for most other lists. Use description lists for pairs of related pieces of data. Use serial commas . Put code-related text in code font . Put UI elements in bold . Use unambiguous date formatting .","title":"Developer documentation style guide"},{"location":"developer-documentation-style-guide/#goals","text":"The guide can help you avoid making decisions about the same issue over and over, can provide editorial assistance on structuring and writing your documentation, and can help you keep your documentation consistent with our other documentation.","title":"Goals"},{"location":"developer-documentation-style-guide/#non-goals","text":"This guide isn't intended to provide an industry documentation standard, nor to compete with other well-known style guides. It's a description of our house style, not a statement that our decisions are objectively correct. This guide is a living document; it changes over time, and when it changes, we generally don't change previously published documentation to match. We strive for consistency to the extent feasible, but at any given time there are certain to be parts of our documentation that don't match this style guide. When in doubt, follow this guide rather than imitating existing documents.","title":"Non-goals"},{"location":"developer-documentation-style-guide/#breaking-the-rules","text":"In most contexts, Nebula has no ability nor desire to enforce these guidelines if they're not appropriate to the context. But we hope that you'll join us in striving for high-quality documentation. Like most style guides, our style guide aims to improve our documentation, especially by improving consistency; therefore, there may be contexts where it makes sense to diverge from our guidelines in order to make your documentation better.","title":"Breaking the \"rules\""},{"location":"developer-documentation-style-guide/#style-and-authorial-tone","text":"Aim, in your documents, for a voice and tone that's conversational, friendly, and respectful without being overly colloquial or frivolous; a voice that's casual and natural and approachable, not pedantic or pushy. Try to sound like a knowledgeable friend who understands what the developer wants to do. Don't try to write exactly the way you speak; you probably speak more colloquially and verbosely than you should write, at least for developer documentation. But aim for a conversational tone rather than a formal one.","title":"Style and authorial tone"},{"location":"developer-documentation-style-guide/#some-techniques-and-approaches-to-consider","text":"If you're having trouble expressing something, step back and ask yourself, \"What am I trying to say?\" Often, the answer you give yourself reveals what you should be saying in the document. If you're uncertain about your phrasing or tone, ask a colleague to take a look. Try reading parts of your document out loud, or at least mouthing the words. Does it sound natural? Not every sentence has to sound natural when spoken; these are written documents. But if you come across a sentence that's awkward or confusing when spoken, consider whether you can make it more conversational. Use transitions between sentences. Phrases like \"Though\" or \"This way\" can make paragraphs less stilted. (Then again, sometimes transitions like \"However\" or \"Nonetheless\" can make paragraphs more stilted.) Even if you're having trouble hitting the right tone, make sure you're communicating useful information in a clear and direct way; that's the most important part.","title":"Some techniques and approaches to consider"},{"location":"developer-documentation-style-guide/#tense","text":"In general, use present tense rather than future tense; in particular, try to avoid using will where possible. The fact that the reader will be writing and running code in the future isn't a good reason to use future tense. Stick with present tense where. Also avoid the hypothetical future would .","title":"Tense"},{"location":"developer-documentation-style-guide/#links","text":"When you're writing link text, use a phrase that describes what the reader will see after following the link. That can take either of two forms: - The exact title of the linked-to page, capitalized the same way the title is capitalized. - A description of the linked-to page, capitalized like ordinary text instead of like a title. A couple of specific things to not do in link text: - Don't use the phrase \"click here.\" (It's bad for accessibility and bad for scannability.) - Similarly, don't use phrases like \"this document.\" (It's easy to read \"this\" as meaning \"the one you're reading now\" rather than \"the one I'm pointing to.\") - Don't use a URL as link text. Instead, use the page title or a description of the page.","title":"Links"},{"location":"developer-documentation-style-guide/#punctuation-with-links","text":"If you have punctuation immediately before or after a link, put the punctuation outside of the link tags where possible. In particular, put quotation marks outside of link tags.","title":"Punctuation with links"},{"location":"developer-documentation-style-guide/#accessible-content","text":"","title":"Accessible content"},{"location":"developer-documentation-style-guide/#general-dos-and-donts","text":"Ensure that readers can reach all parts of the document (including tabs, form-submission buttons, and interactive elements) using only a keyboard, without a mouse or trackpad. Don't use color, size, location, or other visual cues as the primary way of communicating information. If you're using color, icon, or outline thickness to convey state, then also provide a secondary cue, such as a change in the text label. Refer to buttons and other elements by their label (or aria-label , if they\u2019re visual elements), not by location or shape. Avoid unnecessary font formatting. (Screen readers explicitly describe text modifications.) If you're documenting a product that includes specialized accessibility features, then explicitly document those features. For example, the gcloud command-line tool includes togglable accessibility features such as percentage progress bars and ASCII box rendering.","title":"General dos and don'ts"},{"location":"developer-documentation-style-guide/#images","text":"For every image, provide alt text that adequately summarizes the intent of each image. Don't present new information in images; always provide an equivalent text explanation with the image. Use SVG files or crushed PNG images. Provide high-resolution images when practical.","title":"Images"},{"location":"developer-documentation-style-guide/#tables","text":"If your tables include both row and column headings, then mark heading cells with the scope attribute. If your tables have more than one row containing column headings, then use the headers attribute.","title":"Tables"},{"location":"developer-documentation-style-guide/#forms","text":"Label every input field, using a <label> element. Place labels outside of fields. When you're creating an error message for form validation, clearly state what went wrong and how to fix it. For example: \"Name is a required field.\"","title":"Forms"},{"location":"developer-documentation-style-guide/#videos","text":"Provide captions. Ensure that captions can be translated into major languages.","title":"Videos"},{"location":"developer-documentation-style-guide/#language-and-grammar","text":"Use second person: \"you\" rather than \"we.\" Use active voice; make clear who's performing the action. Use standard American spelling and punctuation. Put conditional clauses before instructions, not after. For usage and spelling of specific words, see the word list.","title":"Language and grammar"},{"location":"developer-documentation-style-guide/#formatting-punctuation-and-organization","text":"Use sentence case for document titles and section headings. Use numbered lists for sequences. Use bulleted lists for most other lists. Use description lists for pairs of related pieces of data. Use serial commas . Put code-related text in code font . Put UI elements in bold . Use unambiguous date formatting .","title":"Formatting, punctuation, and organization"},{"location":"get-started/","text":"This tutorial provides a quick introduction to use Nebula Graph. Step 1 Install Nebula Graph \u00b6 The easiest way to startup Nebula is using Docker. Docker is a tool designed to make it easier to create, deploy, and run applications by using containers. Containers allow a developer to package up an application with all of the parts it needs, such as libraries and other dependencies, and ship it all out as one package. By doing so, the developer can rest assured that the application will run on any other Linux machine regardless of any customized settings that machine might have that could differ from the machine used for writing and testing the code. First of all, you should make sure that Docker has been installed on your machine. Open a terminal and run the following command : docker --version If Docker is not found, please see here for more information to install Docker. After that, using docker pull vesoft/nebula-graph:latest to get nebula image and docker images that can display images status. If the pulling is slow when pulling the image, configure a new mirror. 1. Check if the /etc/docker folder exists, if not, create a new one with mkdir -p /etc/docker . Generally the folder will exist after Docker installation. 2. Create the new file daemon.json with the following command tee /etc/docker/daemon.json <<-'EOF' { \"registry-mirrors\": [ \"https://dockerhub.azk8s.cn\", \"https://reg-mirror.qiniu.com\" ] } EOF Or create the new file with vi /etc/docker/daemon.json , then add the following content { \"registry-mirrors\": [ \"https://dockerhub.azk8s.cn\", \"https://reg-mirror.qiniu.com\" ] } Step 2 Startup Nebula Graph \u00b6 When nebula image is ready, run docker run -it vesoft/nebula-graph:latest /bin/bash to start and log in to the Docker container. After login, you're in the root directory and you should use cd ~/nebula-graph/ to switch to the nebula home directory. Run ./start-all.sh to start meta service, storage service and graph service. Run ps -ef | grep nebula to display the services' running status. Please make sure the services are working. bin/nebula is a console which can be used to insert and query data. --port is used for specifying the graph server port and the default value is 3699 . -u and -p are used to specify the user name and password, user and password are the default authority. Run bin/nebula --port=3699 -u=user -p=password to connect to the graph server. One easier way to start console is to run ./start-console.sh Welcome to Nebula Graph (Version 0.1) nebula> Before query the dataset, you should switch to an existing graph space. nebula> use nba Execution succeeded (Time spent: 154/793 us) Step 3 Simple Query Demo \u00b6 This query comes from a vertex walk up an edge. nebula> GO FROM 5209979940224249985 OVER like ======================== | id | ======================== | -7187791973189815797 | ------------------------ | 3778194419743477824 | ------------------------ | -6952676908621237908 | ------------------------ ........................ This query comes from a vertex walk up an edge and the target's age should be greater than or equal to 30, also renames the columns as Player , Friend and Age . nebula> GO FROM 5209979940224249985 OVER like WHERE $$[player].age >= 30 YIELD $^[player].name AS Player, $$[player].name AS Friend, $$[player].age AS Age ============================================= | Player | Friend | Age | ============================================= | Dejounte Murray | Kevin Durant | 30 | --------------------------------------------- | Dejounte Murray | Chris Paul | 33 | --------------------------------------------- | Dejounte Murray | LeBron James | 34 | --------------------------------------------- ............................................. This query comes from a vertex walk up an edge and the target's age should be greater than or equal to 30. Setting output result as input, query Player Name , FromYear , ToYear and Team Name with input's id . In this query, $^ is delegated the source vertex and $$ is the target vertex. $- is used to indicate the input from pipeline. (reference to regular expressions , using the special ^ (hat) and $ (dollar sign) metacharacters to describe the start and the end of the line.) nebula> GO FROM 5209979940224249985 OVER like WHERE $$[player].age >= 30 | GO FROM $-.id OVER serve YIELD $^[player].name AS Player, serve.start_year AS FromYear, serve.end_year AS ToYear, $$[team].name AS Team ===================================================== | Player | FromYear | ToYear | Team | ===================================================== | Kevin Durant | 2016 | 2019 | Warriors | ----------------------------------------------------- | Kevin Durant | 2007 | 2016 | Thunders | ----------------------------------------------------- | Chris Paul | 2017 | 2021 | Rockets | ----------------------------------------------------- ..................................................... For more detail about Query Language, please see Traverse The Graph . Step 4 Advanced Usage \u00b6 Currently you can create your own graph space, such as : CREATE space myspace(partition_num=1, replica_factor=1) When you start Nebula Graph , a set of vertices and edges have already existed. Currently the default schema is nba . The graph space describes the relationship between players and teams. In the graph space, there are two tags (player and team) and two edges (serve and like) which is composed of string and integer . The Schema looks like : Tag team: ================== | Field | Type | ================== | name | string | ------------------ Tag player: ================== | Field | Type | ================== | name | string | ------------------ | age | int | ------------------ Edge serve: ===================== | Field | Type | ===================== | start_year | int | --------------------- | end_year | int | --------------------- Edge like: =================== | Field | Type | =================== | likeness | int | ------------------- You can create both tag and edge's schema: // create tags schema: players and teams: CREATE TAG player(name string, age int) CREATE TAG team(name string) // create edges schema: players and teams: CREATE EDGE like(likeness int) CREATE EDGE serve(start_year int, end_year int) You could describe the schema created, for example: DESCRIBE TAG player DESCRIBE EDGE serve The insert sentences look like the following commands. // Insert some vertices: players and teams: INSERT VERTEX player(name, age) VALUES -8379929135833483044:(\"Amar'e Stoudemire\", 36) INSERT VERTEX team(name) VALUES -9110170398241263635:(\"Magic\") // Insert some edges: likes and serves: INSERT EDGE like(likeness) VALUES -8379929135833483044 -> 6663720087669302163:(90) INSERT EDGE serve(start_year, end_year) VALUES -8379929135833483044 -> 868103967282670864:(2002, 2010)","title":"Quickstart"},{"location":"get-started/#step-1-install-nebula-graph","text":"The easiest way to startup Nebula is using Docker. Docker is a tool designed to make it easier to create, deploy, and run applications by using containers. Containers allow a developer to package up an application with all of the parts it needs, such as libraries and other dependencies, and ship it all out as one package. By doing so, the developer can rest assured that the application will run on any other Linux machine regardless of any customized settings that machine might have that could differ from the machine used for writing and testing the code. First of all, you should make sure that Docker has been installed on your machine. Open a terminal and run the following command : docker --version If Docker is not found, please see here for more information to install Docker. After that, using docker pull vesoft/nebula-graph:latest to get nebula image and docker images that can display images status. If the pulling is slow when pulling the image, configure a new mirror. 1. Check if the /etc/docker folder exists, if not, create a new one with mkdir -p /etc/docker . Generally the folder will exist after Docker installation. 2. Create the new file daemon.json with the following command tee /etc/docker/daemon.json <<-'EOF' { \"registry-mirrors\": [ \"https://dockerhub.azk8s.cn\", \"https://reg-mirror.qiniu.com\" ] } EOF Or create the new file with vi /etc/docker/daemon.json , then add the following content { \"registry-mirrors\": [ \"https://dockerhub.azk8s.cn\", \"https://reg-mirror.qiniu.com\" ] }","title":"Step 1 Install Nebula Graph"},{"location":"get-started/#step-2-startup-nebula-graph","text":"When nebula image is ready, run docker run -it vesoft/nebula-graph:latest /bin/bash to start and log in to the Docker container. After login, you're in the root directory and you should use cd ~/nebula-graph/ to switch to the nebula home directory. Run ./start-all.sh to start meta service, storage service and graph service. Run ps -ef | grep nebula to display the services' running status. Please make sure the services are working. bin/nebula is a console which can be used to insert and query data. --port is used for specifying the graph server port and the default value is 3699 . -u and -p are used to specify the user name and password, user and password are the default authority. Run bin/nebula --port=3699 -u=user -p=password to connect to the graph server. One easier way to start console is to run ./start-console.sh Welcome to Nebula Graph (Version 0.1) nebula> Before query the dataset, you should switch to an existing graph space. nebula> use nba Execution succeeded (Time spent: 154/793 us)","title":"Step 2 Startup Nebula Graph"},{"location":"get-started/#step-3-simple-query-demo","text":"This query comes from a vertex walk up an edge. nebula> GO FROM 5209979940224249985 OVER like ======================== | id | ======================== | -7187791973189815797 | ------------------------ | 3778194419743477824 | ------------------------ | -6952676908621237908 | ------------------------ ........................ This query comes from a vertex walk up an edge and the target's age should be greater than or equal to 30, also renames the columns as Player , Friend and Age . nebula> GO FROM 5209979940224249985 OVER like WHERE $$[player].age >= 30 YIELD $^[player].name AS Player, $$[player].name AS Friend, $$[player].age AS Age ============================================= | Player | Friend | Age | ============================================= | Dejounte Murray | Kevin Durant | 30 | --------------------------------------------- | Dejounte Murray | Chris Paul | 33 | --------------------------------------------- | Dejounte Murray | LeBron James | 34 | --------------------------------------------- ............................................. This query comes from a vertex walk up an edge and the target's age should be greater than or equal to 30. Setting output result as input, query Player Name , FromYear , ToYear and Team Name with input's id . In this query, $^ is delegated the source vertex and $$ is the target vertex. $- is used to indicate the input from pipeline. (reference to regular expressions , using the special ^ (hat) and $ (dollar sign) metacharacters to describe the start and the end of the line.) nebula> GO FROM 5209979940224249985 OVER like WHERE $$[player].age >= 30 | GO FROM $-.id OVER serve YIELD $^[player].name AS Player, serve.start_year AS FromYear, serve.end_year AS ToYear, $$[team].name AS Team ===================================================== | Player | FromYear | ToYear | Team | ===================================================== | Kevin Durant | 2016 | 2019 | Warriors | ----------------------------------------------------- | Kevin Durant | 2007 | 2016 | Thunders | ----------------------------------------------------- | Chris Paul | 2017 | 2021 | Rockets | ----------------------------------------------------- ..................................................... For more detail about Query Language, please see Traverse The Graph .","title":"Step 3 Simple Query Demo"},{"location":"get-started/#step-4-advanced-usage","text":"Currently you can create your own graph space, such as : CREATE space myspace(partition_num=1, replica_factor=1) When you start Nebula Graph , a set of vertices and edges have already existed. Currently the default schema is nba . The graph space describes the relationship between players and teams. In the graph space, there are two tags (player and team) and two edges (serve and like) which is composed of string and integer . The Schema looks like : Tag team: ================== | Field | Type | ================== | name | string | ------------------ Tag player: ================== | Field | Type | ================== | name | string | ------------------ | age | int | ------------------ Edge serve: ===================== | Field | Type | ===================== | start_year | int | --------------------- | end_year | int | --------------------- Edge like: =================== | Field | Type | =================== | likeness | int | ------------------- You can create both tag and edge's schema: // create tags schema: players and teams: CREATE TAG player(name string, age int) CREATE TAG team(name string) // create edges schema: players and teams: CREATE EDGE like(likeness int) CREATE EDGE serve(start_year int, end_year int) You could describe the schema created, for example: DESCRIBE TAG player DESCRIBE EDGE serve The insert sentences look like the following commands. // Insert some vertices: players and teams: INSERT VERTEX player(name, age) VALUES -8379929135833483044:(\"Amar'e Stoudemire\", 36) INSERT VERTEX team(name) VALUES -9110170398241263635:(\"Magic\") // Insert some edges: likes and serves: INSERT EDGE like(likeness) VALUES -8379929135833483044 -> 6663720087669302163:(90) INSERT EDGE serve(start_year, end_year) VALUES -8379929135833483044 -> 868103967282670864:(2002, 2010)","title":"Step 4 Advanced Usage"},{"location":"how-to-build/","text":"General \u00b6 Compiler \u00b6 The project Nebula is developed using C++14, so it requires a compiler supporting C++14 features. 3rd-party Libraries \u00b6 The project itself includes the source code of several 3rd-party libraries, which usually does not exist in the OS's public application repositories. In addition to the included libraries, Nebula requires these 3rd-party utilities and libraries to be installed on the system autoconf automake libtool cmake bison unzip boost gperf krb5 openssl libunwind ncurses readline Currently, we using git-lfs to manage the 3rd-party libraries. So make sure git-lfs have been installed before building the source code. Please see INSTALLING.md for more details.","title":"How to build"},{"location":"how-to-build/#general","text":"","title":"General"},{"location":"how-to-build/#compiler","text":"The project Nebula is developed using C++14, so it requires a compiler supporting C++14 features.","title":"Compiler"},{"location":"how-to-build/#3rd-party-libraries","text":"The project itself includes the source code of several 3rd-party libraries, which usually does not exist in the OS's public application repositories. In addition to the included libraries, Nebula requires these 3rd-party utilities and libraries to be installed on the system autoconf automake libtool cmake bison unzip boost gperf krb5 openssl libunwind ncurses readline Currently, we using git-lfs to manage the 3rd-party libraries. So make sure git-lfs have been installed before building the source code. Please see INSTALLING.md for more details.","title":"3rd-party Libraries"},{"location":"how-to-contribute/","text":"Step 1: Fork in the cloud \u00b6 Visit https://github.com/vesoft-inc/nebula Click Fork button (top right) to establish a cloud-based fork. Step 2: Clone fork to local storage \u00b6 Define a local working directory: # Define your working directory working_dir = $HOME /Workspace Set user to match your github profile name: user ={ your github profile name } Create your clone: mkdir -p $working_dir cd $working_dir git clone https://github.com/ $user /nebula.git # the following is recommended # or: git clone git@github.com:$user/nebula.git cd $working_dir /nebula git remote add upstream https://github.com/vesoft-inc/nebula.git # or: git remote add upstream git@github.com:vesoft-inc/nebula.git # Never push to upstream master since you do not have write access. git remote set-url --push upstream no_push # Confirm that your remotes make sense: # It should look like: # origin git@github.com:$(user)/nebula.git (fetch) # origin git@github.com:$(user)/nebula.git (push) # upstream https://github.com/vesoft-inc/nebula (fetch) # upstream no_push (push) git remote -v Define a pre-commit hook \u00b6 Please link the Nebula Graph pre-commit hook into your .git directory. This hook checks your commits for formatting, building, doc generation, etc. cd $working_dir /nebula/.git/hooks ln -s ../../cpplint/bin/pre-commit.sh . Sometime, pre-commit hook can not be executable. In such case, you have to make it executable manually. cd $working_dir /nebula/.git/hooks chmod +x pre-commit Step 3: Branch \u00b6 Get your local master up to date: cd $working_dir /nebula git fetch upstream git checkout master git rebase upstream/master Branch from master: git checkout -b myfeature NOTE : Because your PR often consists of several commits, which might be squashed while being merged into upstream, we strongly suggest you open a separate topic branch to make your changes on. After merged, this topic branch could be just abandoned, thus you could synchronize your master branch with upstream easily with a rebase like above. Otherwise, if you commit your changes directly into master, maybe you must use a hard reset on the master branch, like: git fetch upstream git checkout master git reset --hard upstream/master git push --force origin master Step 4: Develop \u00b6 Edit the code \u00b6 You can now edit the code on the myfeature branch. Please follow the coding style guidance here . Run stand-alone mode \u00b6 If you want to reproduce and investigate an issue, you may need to run Nebula Graph in stand-alone mode. # Build the binary. make server # Run in stand-alone mode. nebula-graphd Then you can connect the Nebula Graph console to your local server nebula Run Test \u00b6 # Run unit test to make sure all test passed. Step 5: Keep your branch in sync \u00b6 # While on your myfeature branch. git fetch upstream git rebase upstream/master Step 6: Commit \u00b6 Commit your changes. git commit Likely you'll go back and edit/build/test some more than commit --amend in a few cycles. Step 7: Push \u00b6 When ready to review (or just to establish an offsite backup or your work), push your branch to your fork on github.com : git push -f origin myfeature Step 8: Create a pull request \u00b6 Visit your fork at https://github.com/$user/nebula (replace $user obviously). Click the Compare & pull request button next to your myfeature branch. Step 9: Get a code review \u00b6 Once your pull request has been opened, it will be assigned to at least one reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and style. Commit changes made in response to review comments to the same branch on your fork. Very small PRs are easy to review. Very large PRs are very difficult to review.","title":"Contribute to Nebula"},{"location":"how-to-contribute/#step-1-fork-in-the-cloud","text":"Visit https://github.com/vesoft-inc/nebula Click Fork button (top right) to establish a cloud-based fork.","title":"Step 1: Fork in the cloud"},{"location":"how-to-contribute/#step-2-clone-fork-to-local-storage","text":"Define a local working directory: # Define your working directory working_dir = $HOME /Workspace Set user to match your github profile name: user ={ your github profile name } Create your clone: mkdir -p $working_dir cd $working_dir git clone https://github.com/ $user /nebula.git # the following is recommended # or: git clone git@github.com:$user/nebula.git cd $working_dir /nebula git remote add upstream https://github.com/vesoft-inc/nebula.git # or: git remote add upstream git@github.com:vesoft-inc/nebula.git # Never push to upstream master since you do not have write access. git remote set-url --push upstream no_push # Confirm that your remotes make sense: # It should look like: # origin git@github.com:$(user)/nebula.git (fetch) # origin git@github.com:$(user)/nebula.git (push) # upstream https://github.com/vesoft-inc/nebula (fetch) # upstream no_push (push) git remote -v","title":"Step 2: Clone fork to local storage"},{"location":"how-to-contribute/#define-a-pre-commit-hook","text":"Please link the Nebula Graph pre-commit hook into your .git directory. This hook checks your commits for formatting, building, doc generation, etc. cd $working_dir /nebula/.git/hooks ln -s ../../cpplint/bin/pre-commit.sh . Sometime, pre-commit hook can not be executable. In such case, you have to make it executable manually. cd $working_dir /nebula/.git/hooks chmod +x pre-commit","title":"Define a pre-commit hook"},{"location":"how-to-contribute/#step-3-branch","text":"Get your local master up to date: cd $working_dir /nebula git fetch upstream git checkout master git rebase upstream/master Branch from master: git checkout -b myfeature NOTE : Because your PR often consists of several commits, which might be squashed while being merged into upstream, we strongly suggest you open a separate topic branch to make your changes on. After merged, this topic branch could be just abandoned, thus you could synchronize your master branch with upstream easily with a rebase like above. Otherwise, if you commit your changes directly into master, maybe you must use a hard reset on the master branch, like: git fetch upstream git checkout master git reset --hard upstream/master git push --force origin master","title":"Step 3: Branch"},{"location":"how-to-contribute/#step-4-develop","text":"","title":"Step 4: Develop"},{"location":"how-to-contribute/#edit-the-code","text":"You can now edit the code on the myfeature branch. Please follow the coding style guidance here .","title":"Edit the code"},{"location":"how-to-contribute/#run-stand-alone-mode","text":"If you want to reproduce and investigate an issue, you may need to run Nebula Graph in stand-alone mode. # Build the binary. make server # Run in stand-alone mode. nebula-graphd Then you can connect the Nebula Graph console to your local server nebula","title":"Run stand-alone mode"},{"location":"how-to-contribute/#run-test","text":"# Run unit test to make sure all test passed.","title":"Run Test"},{"location":"how-to-contribute/#step-5-keep-your-branch-in-sync","text":"# While on your myfeature branch. git fetch upstream git rebase upstream/master","title":"Step 5: Keep your branch in sync"},{"location":"how-to-contribute/#step-6-commit","text":"Commit your changes. git commit Likely you'll go back and edit/build/test some more than commit --amend in a few cycles.","title":"Step 6: Commit"},{"location":"how-to-contribute/#step-7-push","text":"When ready to review (or just to establish an offsite backup or your work), push your branch to your fork on github.com : git push -f origin myfeature","title":"Step 7: Push"},{"location":"how-to-contribute/#step-8-create-a-pull-request","text":"Visit your fork at https://github.com/$user/nebula (replace $user obviously). Click the Compare & pull request button next to your myfeature branch.","title":"Step 8: Create a pull request"},{"location":"how-to-contribute/#step-9-get-a-code-review","text":"Once your pull request has been opened, it will be assigned to at least one reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and style. Commit changes made in response to review comments to the same branch on your fork. Very small PRs are easy to review. Very large PRs are very difficult to review.","title":"Step 9: Get a code review"},{"location":"nGQL-tutorial/","text":"nGQL Query Language \u00b6 nGQL is the query language of Nebula Graph that allows users to store and retrieve data from the graph database. Nebula Graph wants to make its queries easy to learn, understand, and use for everyone. Key attributes of nGQL \u00b6 Nebula Graph is committed to create a new query language that specifically deals with graph data. nGQL has two attributes that are not available together in any other query language out there. Declarative: nGQL is a declarative query language, which is very different from the imperative alternatives out there. You declare the pattern that you are looking for. You effectively tell nGQL what you want, rather than how to get it. Expressive: nGQL's ASCII-art style syntax provides a familiar, readable way to match patterns of nodes and relationships within graph datasets. nGQL Syntax \u00b6 nGQL key words are case-insensitive but we recommend them written in all caps for easy reading. To help you get a quick understanding of nGQL, we have created a simple graph myspace_test with 4 vertices and 3 edges. Cluster administration \u00b6 Add hosts Add a single host ADD HOSTS $storage_ip:$storage_port Add multiple hosts ADD HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Replace the $storage_ip and $storage_port here according to the local_ip and port in nebula-storaged.conf. Separate the hosts by comma. For example: ADD HOSTS 192.168.8.5:65500 Show hosts SHOW HOSTS ============================= | Ip | Port | Status | ============================= | 192.168.8.5 | 65500 | online | ----------------------- | 192.168.8.1 | 65500 | offline | ----------------------- Remove hosts Remove a single host REMOVE HOSTS $storage_ip:$storage_port Remove multiple hosts REMOVE HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Separate the hosts by comma. Graph administration \u00b6 Graph spaces are physically isolated like the database in MySQL. CREATE DROP USE DESCRIBE SHOW SPACE \u221a \u221a \u221a v0.2 \u221a Create space with CREATE, drop space with DROP, choose which space to use with USE, list available spaces with SHOW. DESCRIBE will be released in v0.2. Following are some examples: List all the spaces available SHOW SPACES ================ | Name | ================ | myspace_test | ---------------- Drop a space DROP SPACE myspace_test Note: DROP SPACE deletes all data in the current version and recovery is not supported yet. Create a space CREATE SPACE myspace_test(partition_num=10, replica_factor=1) Note: partition_num is used to control the number of shardings and replica_factor to control the number of raft copies, which is set to 1 when in stand-alone version. Specify space USE myspace_test Schema mutation \u00b6 Schema is used to manage the properties of vertices and edges (name and type of each field). In Nebula, a vertex can be labeled by multiple tags. CREATE DROP ALTER DESCRIBE SHOW TTL LOAD DUMP TAG \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 EDGE \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 You can use CREATE, DROP, ALTER, DESCRIBE to create, drop, alter, view a schema. Following are some examples: CREATE TAG player(name string, age int); DESCRIBE TAG player; CREATE TAG team(name string); DESCRIBE TAG team; CREATE EDGE serve (start_year int, end_year int); DESCRIBE EDGE serve; CREATE EDGE like (likeness double)\uff1b SHOW TAGS; SHOW EDGES Data manipulation \u00b6 INSERT is used to insert new vertices and edges, UPDATE AND REMOVE will be available in v0.2. INSERT UPDATE REMOVE TAG \u221a v0.2 v0.2 EDGE \u221a v0.2 v0.2 When inserting a vertex, its tag type and ID should be specified, but the attribute field can be ignored(the ignored fields are set to default values). Following are some examples: INSERT VERTEX player(name, age) VALUES 100:(\"Stoudemire\", 36); INSERT VERTEX player(name) VALUES 101:(\"Vicenta\"); -- age is set to default value 0 INSERT VERTEX player(name) VALUES 102:(\"jummy\"); INSERT VERTEX team(name) VALUES 201:(\"Magic\"); INSERT EDGE like (likeness) VALUES 100 -> 101:(90.02); INSERT EDGE like (likeness) VALUES 101 -> 102:(10); INSERT EDGE serve (start_year, end_year) VALUES 101 -> 201:(2002, 2010); Graph query \u00b6 The most commonly used graph query/traversal operator is GO, it means starting from a certain point and querying its 1 degree neighbor. Complex queries can be done by combining pipe | , filtering WHERE , YIELD , etc. Following are some examples: GO FROM 100 OVER like; -- Start from vertex 100, query 1-hop along edge like. GO 2 STEPS FROM 100 OVER like; -- Start from vertex 100, query 2-hop along edge GO FROM 100 OVER like WHERE likeness >= 0; -- Start from vertex 100, query along edge like and filter its property likeness GO FROM 100 OVER like WHERE $$[player].name==\"Vicenta\"; -- Filter requirement: the destination vertex name is \"Vicenta\" GO FROM 101 OVER serve YIELD serve._src AS src_id, $^[player].age AS src_propAge, serve._dst AS dst_id, $$[team].name AS dst_propName; -- Return the starting vertex id(renamed as srcid), source vertex property age, destination vertex id and its name GO FROM 100 OVER like | GO FROM $-.id OVER serve; -- Start from vertex 100, query 1-hop, set its output as the next query's input by using pipe Syntax norms \u00b6 In order to be consistent with ourselves and other nGQL users, we recommend you to follow these syntax norms: KEYWORDS are in uppercase eg: SHOW SPACES the keywords here are all written in uppercase Tags are in upper camel case (start with uppercase\uff09 eg: CREATE TAG ManageTeam the tag name ManageTeam is written in upper camel case EDGES are in upper snake case (like IS_A) eg: CREATE EDGE Play_for (name) the edge name Play_for is written in upper snake case Property names are in lower camel case eg: inService | Graph entity | Recommended style | Example | |:-: | :-: | :-: |:-: | |Key words | Upper case | SHOW SPACES | |Vertex tags | Upper camel case, beginning with an upper-case character | ManageTeam | |Edges | Upper snake case, beginning with an upper-case character | Play_for | |Property names | Lower camel case, beginning with a lower-case character | inService |","title":"nGQL Query Language"},{"location":"nGQL-tutorial/#ngql-query-language","text":"nGQL is the query language of Nebula Graph that allows users to store and retrieve data from the graph database. Nebula Graph wants to make its queries easy to learn, understand, and use for everyone.","title":"nGQL Query Language"},{"location":"nGQL-tutorial/#key-attributes-of-ngql","text":"Nebula Graph is committed to create a new query language that specifically deals with graph data. nGQL has two attributes that are not available together in any other query language out there. Declarative: nGQL is a declarative query language, which is very different from the imperative alternatives out there. You declare the pattern that you are looking for. You effectively tell nGQL what you want, rather than how to get it. Expressive: nGQL's ASCII-art style syntax provides a familiar, readable way to match patterns of nodes and relationships within graph datasets.","title":"Key attributes of nGQL"},{"location":"nGQL-tutorial/#ngql-syntax","text":"nGQL key words are case-insensitive but we recommend them written in all caps for easy reading. To help you get a quick understanding of nGQL, we have created a simple graph myspace_test with 4 vertices and 3 edges.","title":"nGQL Syntax"},{"location":"nGQL-tutorial/#cluster-administration","text":"Add hosts Add a single host ADD HOSTS $storage_ip:$storage_port Add multiple hosts ADD HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Replace the $storage_ip and $storage_port here according to the local_ip and port in nebula-storaged.conf. Separate the hosts by comma. For example: ADD HOSTS 192.168.8.5:65500 Show hosts SHOW HOSTS ============================= | Ip | Port | Status | ============================= | 192.168.8.5 | 65500 | online | ----------------------- | 192.168.8.1 | 65500 | offline | ----------------------- Remove hosts Remove a single host REMOVE HOSTS $storage_ip:$storage_port Remove multiple hosts REMOVE HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Separate the hosts by comma.","title":"Cluster administration"},{"location":"nGQL-tutorial/#graph-administration","text":"Graph spaces are physically isolated like the database in MySQL. CREATE DROP USE DESCRIBE SHOW SPACE \u221a \u221a \u221a v0.2 \u221a Create space with CREATE, drop space with DROP, choose which space to use with USE, list available spaces with SHOW. DESCRIBE will be released in v0.2. Following are some examples: List all the spaces available SHOW SPACES ================ | Name | ================ | myspace_test | ---------------- Drop a space DROP SPACE myspace_test Note: DROP SPACE deletes all data in the current version and recovery is not supported yet. Create a space CREATE SPACE myspace_test(partition_num=10, replica_factor=1) Note: partition_num is used to control the number of shardings and replica_factor to control the number of raft copies, which is set to 1 when in stand-alone version. Specify space USE myspace_test","title":"Graph administration"},{"location":"nGQL-tutorial/#schema-mutation","text":"Schema is used to manage the properties of vertices and edges (name and type of each field). In Nebula, a vertex can be labeled by multiple tags. CREATE DROP ALTER DESCRIBE SHOW TTL LOAD DUMP TAG \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 EDGE \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 You can use CREATE, DROP, ALTER, DESCRIBE to create, drop, alter, view a schema. Following are some examples: CREATE TAG player(name string, age int); DESCRIBE TAG player; CREATE TAG team(name string); DESCRIBE TAG team; CREATE EDGE serve (start_year int, end_year int); DESCRIBE EDGE serve; CREATE EDGE like (likeness double)\uff1b SHOW TAGS; SHOW EDGES","title":"Schema mutation"},{"location":"nGQL-tutorial/#data-manipulation","text":"INSERT is used to insert new vertices and edges, UPDATE AND REMOVE will be available in v0.2. INSERT UPDATE REMOVE TAG \u221a v0.2 v0.2 EDGE \u221a v0.2 v0.2 When inserting a vertex, its tag type and ID should be specified, but the attribute field can be ignored(the ignored fields are set to default values). Following are some examples: INSERT VERTEX player(name, age) VALUES 100:(\"Stoudemire\", 36); INSERT VERTEX player(name) VALUES 101:(\"Vicenta\"); -- age is set to default value 0 INSERT VERTEX player(name) VALUES 102:(\"jummy\"); INSERT VERTEX team(name) VALUES 201:(\"Magic\"); INSERT EDGE like (likeness) VALUES 100 -> 101:(90.02); INSERT EDGE like (likeness) VALUES 101 -> 102:(10); INSERT EDGE serve (start_year, end_year) VALUES 101 -> 201:(2002, 2010);","title":"Data manipulation"},{"location":"nGQL-tutorial/#graph-query","text":"The most commonly used graph query/traversal operator is GO, it means starting from a certain point and querying its 1 degree neighbor. Complex queries can be done by combining pipe | , filtering WHERE , YIELD , etc. Following are some examples: GO FROM 100 OVER like; -- Start from vertex 100, query 1-hop along edge like. GO 2 STEPS FROM 100 OVER like; -- Start from vertex 100, query 2-hop along edge GO FROM 100 OVER like WHERE likeness >= 0; -- Start from vertex 100, query along edge like and filter its property likeness GO FROM 100 OVER like WHERE $$[player].name==\"Vicenta\"; -- Filter requirement: the destination vertex name is \"Vicenta\" GO FROM 101 OVER serve YIELD serve._src AS src_id, $^[player].age AS src_propAge, serve._dst AS dst_id, $$[team].name AS dst_propName; -- Return the starting vertex id(renamed as srcid), source vertex property age, destination vertex id and its name GO FROM 100 OVER like | GO FROM $-.id OVER serve; -- Start from vertex 100, query 1-hop, set its output as the next query's input by using pipe","title":"Graph query"},{"location":"nGQL-tutorial/#syntax-norms","text":"In order to be consistent with ourselves and other nGQL users, we recommend you to follow these syntax norms: KEYWORDS are in uppercase eg: SHOW SPACES the keywords here are all written in uppercase Tags are in upper camel case (start with uppercase\uff09 eg: CREATE TAG ManageTeam the tag name ManageTeam is written in upper camel case EDGES are in upper snake case (like IS_A) eg: CREATE EDGE Play_for (name) the edge name Play_for is written in upper snake case Property names are in lower camel case eg: inService | Graph entity | Recommended style | Example | |:-: | :-: | :-: |:-: | |Key words | Upper case | SHOW SPACES | |Vertex tags | Upper camel case, beginning with an upper-case character | ManageTeam | |Edges | Upper snake case, beginning with an upper-case character | Play_for | |Property names | Lower camel case, beginning with a lower-case character | inService |","title":"Syntax norms"},{"location":"nGQL/","text":"Nebula Graph Query Language (nGQL) \u00b6 About nGQL \u00b6 nGQL is a declarative, textual query language like SQL, but for graphs. Unlike SQL, nGQL is all about expressing graph patterns. nGQL is a work in progress. We will add more features and further simplify the existing ones. There might be inconsistency between the syntax specs and implementation for the time being. Goals \u00b6 Easy to learn Easy to understand To focus on the online queries, also to provide the foundation for the offline computation Features \u00b6 Syntax is close to SQL, but not exactly the same (Easy to learn) Expandable Case insensitive Support basic graph traverse Support pattern match Support aggregation Support graph mutation Support distributed transaction (future release) Statement composition, but NO statement embedding (Easy to read) Prerequisite \u00b6 Directed property graph with schema Terminology \u00b6 Graph Space : A physically isolated space for different graph Tag : A label associated with a list of properties Each tag has a name (human readable string), and internally each tag will be assigned a 32-bit integer Each tag associates with a list of properties, each property has a name and a type There could be dependencies between tags. The dependency is a constrain, for instance, if tag S depends on tag T, then tag S cannot exist unless tag T exists Vertex : A Node in the graph Each vertex has a unique 64-bit (signed integer) ID ( VID ) Each vertex can associate with multiple tags Edge : A Link between two vertices Each edge can be uniquely identified by a tuple Edge type (ET) is a human readable string, internally it will be assigned a 32-bit integer. The edge type decides the property list (schema) on the edge Edge rank is an immutable user-assigned 64-bit signed integer. It affects the edge order between two vertices. The edge with a higher rank value comes first. When not specified, the default rank value is zero Each edge can only be of one type Path : A non-forked connection with multiple vertices and edges between them The length of a path is the number of the edges on the path, which is one less than the number of vertices A path can be represented by a list of vertices, edge types, and rank. An edge is a special path with length==1 <vid, edge_type[:rank], vid, ...> Language Specification \u00b6 General \u00b6 The entire set of statements can be categorized into three classes: query , mutation , and administration Every statement can yield a data set as the result. Each data set contains a schema (column name and type) and multiple data rows Composition \u00b6 Statements could be composed in two ways: Statements could be piped together using operator \" | \", much like the pipe in the shell scripts. The result yielded from the previous statement could be redirected to the next statement as input More than one statements can be batched together, separated by \" ; \". The result of the last statement (or a RETURN statement is executed) will be returned as the result of the batch Data Types \u00b6 Simple type: vid , integer (int64), double , float , bool , string , path , timestamp , year , month (year/month), date , datetime vid : 64-bit signed integer, representing a vertex ID List of simple types, such as integer[] , double[] , string[] Map : A list of KV pairs. The key must be a string , the value must be the same type for the given map Object (future release??): A list of KV pairs. The key mush be a string , the value can be any simple type Tuple List : This is only used for return values . It's composed by both meta data and data (multiple rows). The meta data includes the column names and their types. Type Conversion \u00b6 A simple typed value can be implicitly converted into a list A list can be implicitly converted into a one-column tuple list \"<type>_list\" can be used as the column name Common BNF \u00b6 ::= vid | integer | double | float | bool | string | path | timestamp | year | month | date | datetime ::= ::= | ::= vid (, vid )* | \"{\" vid (, vid )* \"}\" <label> ::= [:alpha] ([:alnum:] | \"_\")* ::= (\"_\")* <label> ::= <label> ::= (, )* ::= :<type> ::= \":\" ::= ::= <tuple> (, <tuple>)* | \"{\" <tuple> (, <tuple>)* \"}\" <tuple> ::= \"(\" VALUE (, VALUE )* \")\" <var> ::= \"$\" <label> Statements \u00b6 Choose a graph space \u00b6 Nebula supports multiple graph spaces. Data in different graph spaces are physically isolated. Before executing a query, a graph space needs to be selected using the following statement USE Return a data set \u00b6 Simply return a single value or a data set RETURN ::= vid | | | <var> Create a tag \u00b6 The following statement defines a new tag CREATE TAG ( ) ::= ::= + ::= , ::= Modify a tag type \u00b6 Create an edge type \u00b6 The following statement defines a new edge type CREATE EDGE ( ) := <label> Modify an edge type \u00b6 Insert vertices \u00b6 The following statement inserts one or more vertices INSERT VERTEX [ NO OVERWRITE ] VALUES ::= ( ) (, ( ))* ::= :( ) (, :( ))* ::= vid ::= (, )* ::= VALUE (, VALUE )* Insert edges \u00b6 The following statement inserts one or more edges INSERT EDGE [ NO OVERWRITE ] [( )] VALUES ( )+ edge_value ::= -> [@ ] : Update a vertex \u00b6 The following statement updates a vertex UPDATE VERTEX SET \\ [ WHERE ] [ YIELD ] ::= | ::= = {, = }+ ::= ( ) = ( ) | ( ) = Update an edge \u00b6 The following statement updates an edge UPDATE EDGE -> [@ ] OF SET [ WHERE ] [ YIELD ] Traverse the graph \u00b6 Navigate from given vertices to their neighbors according to the given conditions. It returns either a list of vertex IDs, or a list of tuples GO [ STEPS ] FROM [ OVER [ REVERSELY ] ] [ WHERE ] [ YIELD ] ::= integer | integer TO integer | UPTO integer ::= [data_set] [[ AS ] ] ::= vid | | | ::= [ AS ] ::= {, }* ::= ::= { AND | OR }\\* ::= > | >= | < | <= | == | != | IN ::= {, }* ::= [ AS ] WHERE clause only applies to the results that are going to be returned. It will not be applied to the intermediate results (See the detail description of the STEP[S] clause) When STEP[S] clause is skipped, it implies one step When going out for one step from the given vertex, all neighbors will be checked against the WHERE clause, only results satisfied the WHERE clause will be returned When going out for more than one step, WHERE clause will only be applied to the final results. It will not be applied to the intermediate results. Here is an example GO 2 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1\" Obviously, you will probably guess the meaning of the query is to get all my fof (friend of friend) whose birthday is after 1988/1/1. You are absolutely right. We will not apply the filter to my friends (in the first step) Here is another example GO UPTO 3 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\" This query tries to find any friend of me whose birthday is after 1988/1/1. If it finds at least one, it will return all the results. If it cannot find any, it will check my friends of friends to see if anyone's birthday is after 1988/1/1. It will return all the non-empty results, otherwise it will check my friends of friends of friends. So, similarly, next query tries to find anyone whose birthday is after 1988/1/1 starting from my 3-hop friends, and finishing at my 5-hop friends GO 3 TO 5 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\" Search \u00b6 Following statements looks for vertices or edges that match certain conditions FIND VERTEX WHERE [ YIELD ] FIND EDGE WHERE [ YIELD ] Pattern match \u00b6 The following statement does a pattern match, and can return tuple list or paths MATCH [ FROM ] [ WHERE ] [ YIELD ] Property Reference \u00b6 It's common to refer a property in the statement, such as in WHERE clause and YIELD clause. In nGQL, the reference to a property is defined as ::= \".\" ::= | | ::= ::= '[' \"]\" <var> always starts with \"$\". There are two special variables: $_ and $$. $_ refers to the input stream, while $$ refers to the destination objects All property names start with a letter. There are a few system property names starting with \"_\". All properties names starting with \"_\" are reserved. Here are some built-in properties: _id : Vertex id _type : Edge type _src : Source ID of the edge _dst : Destination ID of the edge _rank : Edge rank unuber","title":"Nebula Graph Query Language (nGQL)"},{"location":"nGQL/#nebula-graph-query-language-ngql","text":"","title":"Nebula Graph Query Language (nGQL)"},{"location":"nGQL/#about-ngql","text":"nGQL is a declarative, textual query language like SQL, but for graphs. Unlike SQL, nGQL is all about expressing graph patterns. nGQL is a work in progress. We will add more features and further simplify the existing ones. There might be inconsistency between the syntax specs and implementation for the time being.","title":"About nGQL"},{"location":"nGQL/#goals","text":"Easy to learn Easy to understand To focus on the online queries, also to provide the foundation for the offline computation","title":"Goals"},{"location":"nGQL/#features","text":"Syntax is close to SQL, but not exactly the same (Easy to learn) Expandable Case insensitive Support basic graph traverse Support pattern match Support aggregation Support graph mutation Support distributed transaction (future release) Statement composition, but NO statement embedding (Easy to read)","title":"Features"},{"location":"nGQL/#prerequisite","text":"Directed property graph with schema","title":"Prerequisite"},{"location":"nGQL/#terminology","text":"Graph Space : A physically isolated space for different graph Tag : A label associated with a list of properties Each tag has a name (human readable string), and internally each tag will be assigned a 32-bit integer Each tag associates with a list of properties, each property has a name and a type There could be dependencies between tags. The dependency is a constrain, for instance, if tag S depends on tag T, then tag S cannot exist unless tag T exists Vertex : A Node in the graph Each vertex has a unique 64-bit (signed integer) ID ( VID ) Each vertex can associate with multiple tags Edge : A Link between two vertices Each edge can be uniquely identified by a tuple Edge type (ET) is a human readable string, internally it will be assigned a 32-bit integer. The edge type decides the property list (schema) on the edge Edge rank is an immutable user-assigned 64-bit signed integer. It affects the edge order between two vertices. The edge with a higher rank value comes first. When not specified, the default rank value is zero Each edge can only be of one type Path : A non-forked connection with multiple vertices and edges between them The length of a path is the number of the edges on the path, which is one less than the number of vertices A path can be represented by a list of vertices, edge types, and rank. An edge is a special path with length==1 <vid, edge_type[:rank], vid, ...>","title":"Terminology"},{"location":"nGQL/#language-specification","text":"","title":"Language Specification"},{"location":"nGQL/#general","text":"The entire set of statements can be categorized into three classes: query , mutation , and administration Every statement can yield a data set as the result. Each data set contains a schema (column name and type) and multiple data rows","title":"General"},{"location":"nGQL/#composition","text":"Statements could be composed in two ways: Statements could be piped together using operator \" | \", much like the pipe in the shell scripts. The result yielded from the previous statement could be redirected to the next statement as input More than one statements can be batched together, separated by \" ; \". The result of the last statement (or a RETURN statement is executed) will be returned as the result of the batch","title":"Composition"},{"location":"nGQL/#data-types","text":"Simple type: vid , integer (int64), double , float , bool , string , path , timestamp , year , month (year/month), date , datetime vid : 64-bit signed integer, representing a vertex ID List of simple types, such as integer[] , double[] , string[] Map : A list of KV pairs. The key must be a string , the value must be the same type for the given map Object (future release??): A list of KV pairs. The key mush be a string , the value can be any simple type Tuple List : This is only used for return values . It's composed by both meta data and data (multiple rows). The meta data includes the column names and their types.","title":"Data Types"},{"location":"nGQL/#type-conversion","text":"A simple typed value can be implicitly converted into a list A list can be implicitly converted into a one-column tuple list \"<type>_list\" can be used as the column name","title":"Type Conversion"},{"location":"nGQL/#common-bnf","text":"::= vid | integer | double | float | bool | string | path | timestamp | year | month | date | datetime ::= ::= | ::= vid (, vid )* | \"{\" vid (, vid )* \"}\" <label> ::= [:alpha] ([:alnum:] | \"_\")* ::= (\"_\")* <label> ::= <label> ::= (, )* ::= :<type> ::= \":\" ::= ::= <tuple> (, <tuple>)* | \"{\" <tuple> (, <tuple>)* \"}\" <tuple> ::= \"(\" VALUE (, VALUE )* \")\" <var> ::= \"$\" <label>","title":"Common BNF"},{"location":"nGQL/#statements","text":"","title":"Statements"},{"location":"nGQL/#choose-a-graph-space","text":"Nebula supports multiple graph spaces. Data in different graph spaces are physically isolated. Before executing a query, a graph space needs to be selected using the following statement USE","title":"Choose a graph space"},{"location":"nGQL/#return-a-data-set","text":"Simply return a single value or a data set RETURN ::= vid | | | <var>","title":"Return a data set"},{"location":"nGQL/#create-a-tag","text":"The following statement defines a new tag CREATE TAG ( ) ::= ::= + ::= , ::=","title":"Create a tag"},{"location":"nGQL/#modify-a-tag-type","text":"","title":"Modify a tag type"},{"location":"nGQL/#create-an-edge-type","text":"The following statement defines a new edge type CREATE EDGE ( ) := <label>","title":"Create an edge type"},{"location":"nGQL/#modify-an-edge-type","text":"","title":"Modify an edge type"},{"location":"nGQL/#insert-vertices","text":"The following statement inserts one or more vertices INSERT VERTEX [ NO OVERWRITE ] VALUES ::= ( ) (, ( ))* ::= :( ) (, :( ))* ::= vid ::= (, )* ::= VALUE (, VALUE )*","title":"Insert vertices"},{"location":"nGQL/#insert-edges","text":"The following statement inserts one or more edges INSERT EDGE [ NO OVERWRITE ] [( )] VALUES ( )+ edge_value ::= -> [@ ] :","title":"Insert edges"},{"location":"nGQL/#update-a-vertex","text":"The following statement updates a vertex UPDATE VERTEX SET \\ [ WHERE ] [ YIELD ] ::= | ::= = {, = }+ ::= ( ) = ( ) | ( ) =","title":"Update a vertex"},{"location":"nGQL/#update-an-edge","text":"The following statement updates an edge UPDATE EDGE -> [@ ] OF SET [ WHERE ] [ YIELD ]","title":"Update an edge"},{"location":"nGQL/#traverse-the-graph","text":"Navigate from given vertices to their neighbors according to the given conditions. It returns either a list of vertex IDs, or a list of tuples GO [ STEPS ] FROM [ OVER [ REVERSELY ] ] [ WHERE ] [ YIELD ] ::= integer | integer TO integer | UPTO integer ::= [data_set] [[ AS ] ] ::= vid | | | ::= [ AS ] ::= {, }* ::= ::= { AND | OR }\\* ::= > | >= | < | <= | == | != | IN ::= {, }* ::= [ AS ] WHERE clause only applies to the results that are going to be returned. It will not be applied to the intermediate results (See the detail description of the STEP[S] clause) When STEP[S] clause is skipped, it implies one step When going out for one step from the given vertex, all neighbors will be checked against the WHERE clause, only results satisfied the WHERE clause will be returned When going out for more than one step, WHERE clause will only be applied to the final results. It will not be applied to the intermediate results. Here is an example GO 2 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1\" Obviously, you will probably guess the meaning of the query is to get all my fof (friend of friend) whose birthday is after 1988/1/1. You are absolutely right. We will not apply the filter to my friends (in the first step) Here is another example GO UPTO 3 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\" This query tries to find any friend of me whose birthday is after 1988/1/1. If it finds at least one, it will return all the results. If it cannot find any, it will check my friends of friends to see if anyone's birthday is after 1988/1/1. It will return all the non-empty results, otherwise it will check my friends of friends of friends. So, similarly, next query tries to find anyone whose birthday is after 1988/1/1 starting from my 3-hop friends, and finishing at my 5-hop friends GO 3 TO 5 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\"","title":"Traverse the graph"},{"location":"nGQL/#search","text":"Following statements looks for vertices or edges that match certain conditions FIND VERTEX WHERE [ YIELD ] FIND EDGE WHERE [ YIELD ]","title":"Search"},{"location":"nGQL/#pattern-match","text":"The following statement does a pattern match, and can return tuple list or paths MATCH [ FROM ] [ WHERE ] [ YIELD ]","title":"Pattern match"},{"location":"nGQL/#property-reference","text":"It's common to refer a property in the statement, such as in WHERE clause and YIELD clause. In nGQL, the reference to a property is defined as ::= \".\" ::= | | ::= ::= '[' \"]\" <var> always starts with \"$\". There are two special variables: $_ and $$. $_ refers to the input stream, while $$ refers to the destination objects All property names start with a letter. There are a few system property names starting with \"_\". All properties names starting with \"_\" are reserved. Here are some built-in properties: _id : Vertex id _type : Edge type _src : Source ID of the edge _dst : Destination ID of the edge _rank : Edge rank unuber","title":"Property Reference"},{"location":"nebula-design-concepts/","text":"Data modeling and architecture of Nebula Graph \u00b6 Directed property graph \u00b6 Modeling data with directed property graph, Nebula Graph is very easy to understand. That is to say, Nebula Graph consists of two graph elements logically: Vertex, type of vertex (tag) the corresponding vertex attribute: In Nebula Graph, the type of vertex is called a tag. A vertex must have at least one type (tag) or multiple types (tag). Each tag has a corresponding set of properties called schema. Consider the above picture as example, there are two types of vertices: player and team. Vertex player's schema has three attributes: id (vid), Name(string), and Age(int); vertex team's schema has two attributes: id (vid) and Name(string). Like Mysql, Nebula Graph is a strong schema database. The name and data type of the attribute are determined before the data is written.","title":"Data modeling and architecture of Nebula Graph"},{"location":"nebula-design-concepts/#data-modeling-and-architecture-of-nebula-graph","text":"","title":"Data modeling and architecture of Nebula Graph"},{"location":"nebula-design-concepts/#directed-property-graph","text":"Modeling data with directed property graph, Nebula Graph is very easy to understand. That is to say, Nebula Graph consists of two graph elements logically: Vertex, type of vertex (tag) the corresponding vertex attribute: In Nebula Graph, the type of vertex is called a tag. A vertex must have at least one type (tag) or multiple types (tag). Each tag has a corresponding set of properties called schema. Consider the above picture as example, there are two types of vertices: player and team. Vertex player's schema has three attributes: id (vid), Name(string), and Age(int); vertex team's schema has two attributes: id (vid) and Name(string). Like Mysql, Nebula Graph is a strong schema database. The name and data type of the attribute are determined before the data is written.","title":"Directed property graph"}]}